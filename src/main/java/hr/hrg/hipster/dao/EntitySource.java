package hr.hrg.hipster.dao;

import java.lang.reflect.InvocationTargetException;
import java.util.*;
import java.util.concurrent.*;

import hr.hrg.hipster.sql.*;

public class EntitySource {
	protected Map<Class<? extends Object>, IEntityMeta<?,?,?>> registered = new ConcurrentHashMap<>(); 
	protected Map<String, IEntityMeta<?,?,?>> named = new ConcurrentHashMap<>();

	private TypeSource typeSource;
	private int entityIndex = 0;

	public EntitySource() {
	}
	
	public EntitySource(TypeSource resultGetterSource) {
		this.typeSource = resultGetterSource;
	}
	
	protected <T> void registerFor(IEntityMeta<T, ?,?> meta){
		registerFor(meta, meta.getEntityClass());
	}

	protected <T> void registerFor(IEntityMeta<T, ?,?> meta, Class<T> clazz){
		registered.put(clazz, meta);
		named.put(clazz.getSimpleName(), meta);
	}

	@SuppressWarnings("unchecked")
	public <T> IEntityMeta<T, ?,? extends BaseColumnMeta> getFor( Class<T> clazz){
		IEntityMeta<T, ?, ?> ret = (IEntityMeta<T, ?,? extends BaseColumnMeta>) registered.get(clazz);
		if(ret == null){
			ret = (IEntityMeta<T, ?, ?>) loadHandlerFromClass(HipsterSqlUtil.entityNamesPrefix(clazz)+"Meta");
			if(ret != null) registerFor(ret, clazz);
		}
		return ret;
	}
	
	public <T> IEntityMeta<T, ?,? extends BaseColumnMeta> getForRequired( Class<T> clazz){
		IEntityMeta<T, ?, ?> ret = getFor(clazz);
		
		if(ret == null) throw new RuntimeException("Meta not found for "+clazz.getName());
		
		return ret;
	}

	public IEntityMeta<?, ?,? extends BaseColumnMeta> getFor(String name){
		return named.get(name);
	}

	public IEntityMeta<?, ?,? extends BaseColumnMeta> getForRequired(String name){
		IEntityMeta<?, ?, ?> ret = named.get(name);
		
		if(ret == null) throw new RuntimeException("Meta not found for "+name);

		return ret;
	}

	public IEntityMeta<?,?,?> loadHandlerFromClass(String cName) {
		if(typeSource == null) return null;
		try {
			Class<?> meta = Class.forName(cName);
			// found if no exception, now we just need to construct new instance
			if(IEntityMeta.class.isAssignableFrom(meta)) {				
				return newInstance(meta);
			}
		} catch (ClassNotFoundException e) {
			// ok, no Meta generated by hipster-processor
		} catch (Exception e) {
			throw new RuntimeException("Found possible generated Visitor handler class, but faild to instantiate ",e);
		}
		return null;
	}

	protected IEntityMeta<?, ?, ?> newInstance(Class<?> meta)	throws InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException {
		return (IEntityMeta<?, ?, ?>) meta.getConstructor(new Class<?>[]{TypeSource.class, int.class}).newInstance(typeSource, entityIndex++);
	}

	@SafeVarargs
	public final void registerBoth(ReaderSource readerSource, Class<? extends IEntityMeta> ...metas ){
		try {			
			for (Class<? extends IEntityMeta> meta : metas) {
				IEntityMeta<?, ?, ?> instance = newInstance(meta);
				registerFor(instance);
				readerSource.registerFor(instance);
			}
		} catch (Exception e) {
			throw new RuntimeException(e.getMessage(),e);
		}
	}

	public int getEntityCount() {
		return entityIndex;
	}
	
}
